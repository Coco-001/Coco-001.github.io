<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Java虚拟机</title>
    <link href="/2022/10/11/JVM/"/>
    <url>/2022/10/11/JVM/</url>
    
    <content type="html"><![CDATA[<ol><li><p>JVM包括哪几部分？</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690687338/9602C6323C6B86C4EDA164DB052D8420" alt="JVM组成"></p></li><li><p>Java程序是怎么运行的？</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690729850/2B33427D8F51F7F8EADC74E0034C5FC7" alt="Java程序运行过程"></p></li><li><p>Java代码的编译过程。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690771024/D5A5CF19C86BD497E892012DFFC26B0E" alt="Java代码编译过程"></p></li><li><p>类的生命周期。</p></li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690785011/2F1143CD0902210BA8783DBC8CB76D0A" alt="类加载过程"></p><ol start="5"><li><p>对象实例化顺序。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690800773/9285BA6FB2D1E24A711E876B40F6E978"></p></li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690813265/7F511C22AD3C8FA49BFA8D92452E6CB3"></p><ol start="6"><li><p>Java类加载器和双亲委派模型。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690834665/8E2E9DCFA8BD05816F2C6E5041254667"></p></li></ol><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。（保证类的加载不出现问题）</p><ol start="7"><li><p>GC机制。</p><ul><li><p>怎么定义垃圾？</p><p>引用计数法（循环引用问题）、可达性分析（哪些对象可以作为GC Roots？）</p><p>方法区的垃圾（废弃的常量和不再使用的类型）</p></li><li><p>怎么回收垃圾？<br>理论基础：弱分代假说（朝生夕灭），强分代假说（熬过越多次GC的对象越难消亡），跨代引用假说（用于永久代的记录集）<br>收集算法：<br>标记清除（执行效率不稳定、内存的碎片化问题）<br>半区复制的标记复制算法（内存复制的开销、内存缩减为一半）-&gt; 半区复制分代的标记复制算法（如ParNew收集器：Eden : s1 : s2 &#x3D; 8 : 1 : 1，存活对象超过10%使用老年代进行分配担保，适用于新生代）<br>标记整理算法（复制算法在存活率高的时候开销较大，且需要额外空间进行担保），适用于老年代</p></li></ul></li><li><p>JVM中一次完整的GC流程。</p><p>当Eden区完全挤满，此时将触发Minor GC。</p><p>在正式 Minor GC 前，JVM 会先检查新生代中对象，是比老年代中剩余空间大还是小。为什么要做这样的检查呢？原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：</p><ol><li><p>老年代剩余空间大于新生代中的对象大小，那就直接Minor GC，GC完survivor不够放，老年代也绝对够放；</p></li><li><p>老年代剩余空间小于新生代中的对象大小，这个时候就要查看是否启用了“老年代空间分配担保规则”，具体来说就是看 -XX:-HandlePromotionFailure 参数是否设置了。</p><p>老年代空间分配担保规则是这样的，如果老年代中剩余空间大小，大于历次 Minor GC 之后剩余对象的大小，那就允许进行 Minor GC。因为从概率上来说，以前的放的下，这次的也应该放的下。那就有两种情况：</p><p>老年代中剩余空间大小，大于历次Minor GC之后剩余对象的大小，进行 Minor GC；</p><p>老年代中剩余空间大小，小于历次Minor GC之后剩余对象的大小，进行Full GC，把老年代空出来再检查。</p></li></ol><p>开启老年代空间分配担保规则只能说是大概率上来说，Minor GC 剩余后的对象够放到老年代，所以当然也会有万一，Minor GC 后会有这样三种情况：</p><ol><li>Minor GC 之后的对象足够放到 Survivor 区，皆大欢喜，GC 结束；</li><li>Minor GC 之后的对象不够放到 Survivor 区，接着进入到老年代，老年代能放下，那也可以，GC 结束；</li><li>Minor GC 之后的对象不够放到 Survivor 区，老年代也放不下，那就只能 Full GC。</li></ol><p>前面都是成功 GC 的例子，还有 3 中情况，会导致 GC 失败，报 OOM：</p><ol><li>紧接上一节 Full GC 之后，老年代任然放不下剩余对象，就只能 OOM；</li><li>未开启老年代分配担保机制，且一次 Full GC 后，老年代任然放不下剩余对象，也只能 OOM；</li><li>开启老年代分配担保机制，但是担保不通过，一次 Full GC 后，老年代任然放不下剩余对象，也是能 OOM。</li></ol></li><li><p>如何减少FullGC的次数？</p><p>增加方法区的空间、增加老年代的空间、减少新生代的空间、禁止使用System.gc()方法、使用标记-整理算法，尽量保持较大的连续内存空间、排查代码中无用的大对象。</p></li><li><p>对象如何晋升到老年代？</p><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。</p></li><li><p>G 1（Garbage First）</p><p>G1（Garbage First）是一款主要面向服务端应用的垃圾收集器，JDK 9发布之日，G1成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。G1收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p><p>虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数 -XX：G1HeapRegionSize 设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region 之中，G1的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待，如下图所示。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645691138195/247F7CD9892EB01A7A3ECBC7193FA032"></p></li></ol><p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p><ol start="12"><li><p>CMS收集器</p><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645691156932/139DF2625D59EBF58A1FA8BBC0D38988"></p></li></ol><p>问题：</p><p>CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。</p><p>由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop TheWorld”的Full GC的产生。</p><p>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot整合Redis连接不上的几种情况</title>
    <link href="/2022/05/26/Springboot%E6%95%B4%E5%90%88Redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/26/Springboot%E6%95%B4%E5%90%88Redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot整合Redis连接不上的几种情况"><a href="#Springboot整合Redis连接不上的几种情况" class="headerlink" title="Springboot整合Redis连接不上的几种情况"></a>Springboot整合Redis连接不上的几种情况</h1><p>今天在给之前写的个人运动健康项目引入Redis作为缓存的时候，出现了错误，错误信息如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">connection</span> refused: <span class="hljs-keyword">no</span> further information <br><br>java.nio.channels.ClosedChannelException: <span class="hljs-keyword">null</span><br><br>io.lettuce.core.RedisConnectionException: Unable <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6739</span>] <span class="hljs-keyword">with</span> root cause<br></code></pre></td></tr></table></figure><p>在网上搜索了好久，得到的答案都是相互复制，没一个有效的解决方案，后面自己解决了，这里总结一下出错常见的几种情况；</p><h2 id="1-redis版本带来的连接出错问题："><a href="#1-redis版本带来的连接出错问题：" class="headerlink" title="1. redis版本带来的连接出错问题："></a>1. redis版本带来的连接出错问题：</h2><p>Java 操作 Redis 的库有两个，Jedis和 Lettuce，目前 SpringBoot 2.x 中已经将 Jedis 换成了 Lettuce，Lettuce是连接Redis Server的客户端程序，Redis客户端使用RESP（Redis的序列化协议）协议与Redis的服务器端进行通信。Redis5及以下默认使用RESP2进行连接，Redis6及以上版本需要使用RESP3连接。</p><p>SpringBoot2.5.7使用的lettuce版本是6.1.5，连接Redis时默认通过RESP3协议，如果redis的版本低于6.0，此时会失败，需要手动改回RESP2。</p><p>建议直接引入Jedis，然后引入通池依赖 commons-pool2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 排除Lettuce影响 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.lettuce<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lettuce-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-配置文件问题"><a href="#2-配置文件问题" class="headerlink" title="2. 配置文件问题"></a>2. 配置文件问题</h2><h3 id="1-Redis配置文件问题"><a href="#1-Redis配置文件问题" class="headerlink" title="1. Redis配置文件问题"></a>1. Redis配置文件问题</h3><ul><li><p>如果你的Redis没有设置密码（默认无密码），springboot配置文件中就不要配置password；</p></li><li><p>注意查看Redis的配置文件中protected-mode，如果该项为yes，则必须设置密码才能连接Redis（默认是设置成yes的， 防止了远程访问，在redis3.2.3版本后）;</p></li><li><p>注意查看Redis的配置文件中bind，如果绑定了的ip没有当前尝试连接的机器的ip（默认绑定127.0.0.1），则无法连接；</p></li></ul><h3 id="2-timeout设置得不能太小，否则网络慢的话，还没等连上就接超时了；"><a href="#2-timeout设置得不能太小，否则网络慢的话，还没等连上就接超时了；" class="headerlink" title="2. timeout设置得不能太小，否则网络慢的话，还没等连上就接超时了；"></a>2. timeout设置得不能太小，否则网络慢的话，还没等连上就接超时了；</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">spring:<br>  # 连接本地的Redis<br>  redis:<br>    database: 0<br>    port: 6379<br>    host: 127.0.0.1<br>    timeout: 5000<br></code></pre></td></tr></table></figure><h2 id="3-是否开放对应端口"><a href="#3-是否开放对应端口" class="headerlink" title="3. 是否开放对应端口"></a>3. 是否开放对应端口</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">#这里用的是firewall防火墙配置，开放端口并重启<br>firewall-cmd --zone=public --add-port=6379/tcp --permanent <br><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
